## Java内存模型JMM - Java Memory Model
1. Java内存模型规定所有的变量都是存在主存当中（类似于物理内存），每个线程都有自己的工作内存（类似于高速缓存）。
2. 线程对变量的所有操作都必须在工作内存（高速缓存）中进行，而不能直接对主存进行操作。
3. 并且每个线程不能访问其他线程的工作内存。

## Jvm内存结构（运行时数据区域）
1. 线程私有区域【程序计数器、虚拟机栈、本地方法栈】
2. 线程共享区域【Java堆（新生代、老年代）、方法区（永久代）】

### 程序计数器
程序计数器是为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。

### 虚拟机栈
虚拟机栈中包含多个栈帧，这些栈帧是和每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息，每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的方法，程序计数器也会指向该地址。

### 堆
堆是JVM所管理的内存中国最大的一块，是被所有Java线程所共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，Java堆是GC管理的主要区域。

### 方法区
方法区存放了要加载的class的信息、类中的静态变量、类中定义为final类型的常量

### 本地方法栈
本地方法栈为JVM执行Native方法服务，作用同虚拟机栈

## GC是如何进行内存分配和垃圾回收的？
垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾回收算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄漏。

## 什么时候会出现内存泄漏
内存泄漏是指无用对象持续占有内存导致内存得不到释放，从而导致内存空间的浪费称为内存泄漏。

## 引起内存泄漏的常见原因有哪些
### 静态集合类引起内存泄漏
静态的HashMap、Vector很容易出现内存泄漏，这些静态变量的生命周期和应用程序一直，他们所引用的所有object也不能被释放。

例子：仅仅将object置为null没用，因为vector仍然引用这个对象，它对于GC来说是不可回收的。处理的办法是将vector置为null
```
Static Vector v = new Vector(10); 
for (int i = 1; i < 100; i++) { 
    Object o = new Object(); 
    v.add(o); 
    o = null; 
}
```

### 当集合里面的对象属性被修改后，再调用remove方法不起作用

```
public static void main(String[] args) { 
    Set<Person> set = new HashSet<Person>(); 
    Person p1 = new Person("唐僧","pwd1",25); 
    Person p2 = new Person("孙悟空","pwd2",26); 
    Person p3 = new Person("猪八戒","pwd3",27); 
    set.add(p1); 
    set.add(p2); 
    set.add(p3); 
    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! 
    
    p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 
    
    set.remove(p3); //此时remove不掉，造成内存泄漏
    set.add(p3); //重新添加，居然添加成功，因为修改后变成不同的对象了
    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! 
}
```

### 各种连接
比如数据库连接connection、网络连接socket、IO连接，除非将其显式的close关闭，否则是不会自动被GC回收的

### 单例模式
不正确的使用单例模式是引起内存泄漏的一个常见问题，单例对象因为是静态的，所以在初始化后将在JVM的整个生命周期中存在，
如果单例对象持有外部的引用，那么整个对象将不能被JVM正常回收，导致内存泄漏。

## 如何分析生产环境内存泄漏
1. 把java应用的dump文件打出来。
2. 使用分析工具，找出内存超出预期的嫌疑对象。
3. 查看源代码，找出嫌疑对象数量过多的原因。

## 常见垃圾收集算法
### 标记-清除算法
分为两个阶段，标记和清除。标记阶段标记处所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。
该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。

### 复制算法
为了解决标记清除算法内存碎片法缺陷而被提出的算法。
按内存容量将内存划分为大小相同的两块，每次只使用其中一块，当一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清理掉。
这种算法虽然简单，内存效率高，不容易产生碎片，但是最大的问题是可用内存被压缩到了原来的一半。且存活对象增多的话，复制算法的效率会大大降低。

### 标记-整理算法
结合了上面两个算法，为了避免缺陷而提出，标记对象后不是清理对象，而是将存活的对象移向内存的一端，然后清除掉端边界外的对象。

### 分代算法
根据对象存活周期的不同将内存划分为几块，一般为新生代和老年代。
新生代的特点是每次垃圾回收都有大量的垃圾需要被回收，因此采用复制算法
老年代每次垃圾回收只有少量的对象需要被回收，因此采用标记整理算法。

## Jvm有哪些垃圾回收器？
1. CMS：使用标记整理清除算法
2. G1: 基于标准整理算法，是JDK9以后的默认GC选项

## 垃圾回收器是怎么工作的？
Java堆从GC的角度分为：新生代和老年代，新生代占1/3，老年代占2/3
由于频繁创建对象，新生代会频繁触发MinorGC进行垃圾回收   
新生代MinorGC使用复制算法，新生代有3个分区：Eden（新对象诞生地）、To Survivor、From Survivor，他们默认占比8：1：1

执行流程如下：（复制算法）
1. 把Eden + From Survivor存活的对象放入To Survivor区
2. 清空Eden和From Survivor分区
3. From Survivor和To Survivor分区交换，From Survivor变To Survivor，To Survivor变From Survivor
每次在From Survivor到To Survivor移动时都存活的对象，年龄+1，当年龄达到15时，升级为老年代。
大对象也会进入老年代。老年代当空间占用达到某个值之后就会触发全局垃圾回收(Major GC)，一般使用标记清除执行算法。

## 老年代中对象何时被清理？
老年代对象比较稳定，所以Major GC不会频繁执行，在进行Major GC前一般会先进行Minor GC，使得有新生代对象进入老年代，导致空间不够时才会触发Major GC，当无法找到足够大的连续空间分配给新创建的较大对象时，也会提前触发一次Major GC进行垃圾回收以便腾出空间。

## 如何判断对象已经死亡成为垃圾？
### 引用计数法
java中操作对象使用引用，如果一个对象没有任何与之关联的引用，那么引用计数就是0，说明对象不太可能会被用到，这个对象就是可回收对象。（存在循环引用的问题）

### 可达性分析法
通过一些被称为GC Root的对象作为起点，从这些节点开始搜索，如果从GC root到某节点不可达，说明该对象不可用。
不可达对象不等价于可回收对象，不可达对象编程可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

## 永久代中会存放哪些信息？
永久代指内存的永久保存区域，主要存放Class和元数据信息，Class被加载的时候被放入永久区域，GC不会在主程序运行期对永久区域进行清理。所以这也导致永久代的区域会随着加载的Class增多而胀满，最终抛出OOM异常。

## 类加载器分类：
1. 启动类加载器（Bootstrap ClassLoader）- 用来加载Java_Home/lib目录中的类库
2. 扩展类加载器（Extension ClassLoader）- 用来加载lib/ext目录下类库
3. 应用程序类加载器（Application ClassLoader）- 用来加载用户类路径上类

## 双亲委派模型：
如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是将请求委派给父类加载器去完成，如果父类加载器还存在其父类加载器，则进一步向上委托，这样所有的加载请求都会被传送到顶层的BootstrapClassLoader中，只有当父加载器无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载类。

每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成

好处：防止父类加载了此类，子类又加载了一次。另外处于安全考虑，防止核心API库被随意篡改

## 如何打破双亲委派模型
自己实现一个类加载器

## JVM启动参数的意义
-Xmx3550m：设置JVM堆最大可用内存为3550M。
-Xms3550m：设置JVM堆初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。

-Xss128k：设置每个线程的栈大小。（JDK5.0以后每个线程堆栈大小为1M）
-Xmn1024m：设置年轻代大小为1024m。等效于同时配置下面两个。
-XX:NewSize=1024m：设置年轻代初始值为1024M。
-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。

-XX:PermSize=256m：设置持久代初始值为256M。
-XX:MaxPermSize=256m：设置持久代最大值为256M。

## 聊聊啥是CMS

### 什么是CMS
CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，针对老年代

### 如何使用
如果老年代使用CMS垃圾回收器，需要添加虚拟机参数-”XX:+UseConcMarkSweepGC”。

### 使用场景
在一些对响应时间有很高要求的应用或网站中，用户线程不能有长时间的停顿，CMS可以用于此场景。

### 缺点
服务长时间运行，使用标记清除算法，造成严重的内存碎片化。如果有大对象过来，会触发一次FULL GC

### 如何判断对象是否存活
一般来说通过GC ROOT可达的对象就是活着的。

## Full GC的触发条件
1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

## Java中可作为GC ROOT的对象有哪些?
1. 虚拟机栈中引用的对象
2. 本地方法栈(native)引用的对象
3. 方法区中引用的对象

## 垃圾回收器CMS和G1有什么区别？
### 使用范围不一样
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用。
G1收集器收集的范围是老年代和新生代，不需要结合其他收集器使用。

### STW的时间
降低停顿时间是G1和CMS共同的关注点，CMS收集器以最小停顿时间为目标的收集器。
G1除了追求低停顿外，还能预测垃圾回收的停顿时间。

### 垃圾碎片
CMS收集器使用标记-清除算法进行垃圾回收，容易产生内存碎片。
G1收集器使用的是标记-整理算法，进行了空间整合，降低了内存空间碎片。