## ACID是什么
#### Atomicity原子性
一个事务中的所有操作，要么全部成功，要么全部失败，不会结束在中间某个环节，事务不可分割。

#### Consistency一致性
在事务开始之前和事务结束之后，数据的完整性不会被破坏。
500经过转账后，其和仍然是500

#### Isolation隔离性
并发执行的各个事务之间互不干扰

隔离分为不同级别：读未提交、读已提交、可重复读、串行化

#### Durability持久性
事务一旦提交，其结果将保存到数据库中

## Mysql事务的隔离级别
#### Read-Uncommitted
事务未提交就可被其他事务读取

#### Read-Committed
一个事务提交后才能被其他事务读取到

#### Repeatable-Read
mysql默认级别，保证多次读取同一个数据，其值都和事务开始的时候是一致的。

#### serializable
代价最高最可靠的隔离界别，可防止脏读、不可重复读、幻读。

不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

## Mysql常用引擎

#### innoDB
1. 提供了对事务的支持
2. 提供了行级锁，锁粒度小，高并发时效率高
3. 不会保存表的行数，count(*)走全表扫描

#### MyIASM
1. 不提供事务支持
2. 插入或更新会锁整个表
3. 保存了表的行数，count(*)不会走全表扫描
4. 如果读操作远远大于写，可考虑选择

## 数据库三范式是什么？
1. 要求属性具有原子性，不能再拆分
2. 每个表都得有个唯一标示，即主键
3. 消除冗余字段

## Mysql中有哪几种日志
#### redo log - 重做日志
物理格式的日志，确保事务的持久性，防止在发生故障的时候，有数据未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性。

#### undo log - 回滚日志
逻辑格式的日志，保存了事务发生之前的数据的一个版本，可以用于回滚恢复至事务之前的状态。

#### binlog - 二进制日志
在主从复制使，从库利用主库的binlog实现主从同步

#### errorlog - 错误日志
记录一些错误警告信息

#### slow query log - 慢查询日志
设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。

#### general log - 一般查询日志
记录对数据库请求的信息

#### relay log - 中继日志

## MySql的undolog的作用
undo log有两个作用：提供回滚和多个行版本控制(MVCC)。

在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。

## mysql explain各种参数及意义
#### type
访问类型，结果值从好到坏依次为
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref
尽量避免为ALL，因为这是全表扫描

#### possible_keys
揭示哪一些索引可能有利于高效的查找

#### key
实际使用的索引

#### rows
为了找到所需的行而需要读取的行数

## mysql锁机制
锁主要用于共享资源的并发访问，用于实现事务的隔离性。
InnoDB的行级锁是基于索引实现的，如果查询语句未命中任何索引，那么InnoDB会使用表级锁.

### 锁的粒度分类
#### 表锁
系统开销最小，会锁定整张表，MyIsam使用表锁。

#### 行锁
最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。

### 按是否可写分类

#### 共享锁（S锁-Share Locks）
所谓共享锁，全称应该为共享读锁，即多个事务可以同时加共享锁，读取同一个对象。这也就是『共享』二字的含义。

#### 排他锁（X锁 - Exclusive locks）
一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。

### 两个表级锁：IS和IX
这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录。意向锁是InnoDB自动加的，不需要用户干预。

#### 意向共享锁（IS）
表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。

#### 意向排他锁（IX）
表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。

#### 锁的算法
1. Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；

2. Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围，不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。间隙锁只会在Repeatable read隔离级别下使用；

3. Next-key Lock：锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题；next-key锁主要是针对非唯一索引；

## 数据库什么情况下会加锁
一条语句需要加的锁收到很多条件制约，比如事务的隔离级别、语句执行时用到的索引等
加锁是为了解决并发事务执行过程中引起的脏写、脏读、不可重复读、幻读。
    
#### 普通的SELECT语句
1. `READ UNCOMMITTED`隔离级别下，不加锁，直接读取记录的最新版本，可能发生`脏读`、`不可重复读`和`幻读`问题。

2. `READ COMMITTED`隔离级别下，不加锁，在每次执行普通的`SELECT`语句时都会生成一个`ReadView`，这样解决了`脏读`问题，但没有解决`不可重复读`和`幻读`问题。

3. `REPEATABLE READ`隔离级别下，不加锁，只在第一次执行普通的`SELECT`语句时生成一个`ReadView`，这样把`脏读`、`不可重复读`和`幻读`问题都解决了。

#### 锁定读的语句
1. 语句一：`SELECT ... LOCK IN SHARE MODE;`
2. 语句二：`SELECT ... FOR UPDATE;`
3. 语句三：`UPDATE ...`
4. 语句四：`DELETE ...`
5. 语句五：`INSERT ...`

## MySql的MVCC的机制。
MVCC，Multi-Version Concurrency Control，多版本并发控制。一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；

如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题。比如通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读操作，在某个瞬间看到的是数据库的一个快照，写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读来说是不可见的。

MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用时间戳或者事务 ID去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。

## RR级别下的快照读和当前读
#### 快照读
快照读就是读历史数据，通过MVVC(多版本控制)和undo log来实现，可以避免幻读。

对于快照读，select时只会读取小于等于当前事务版本的行，但是新行的版本号是高于读事务的，那么新插入的行对之前的读事务是不可见的。

实现：简单的select操作(不包括select ... lock in share mode, select ... for update)

#### 当前读
当前读最新数据，通过加record lock(记录锁)和gap lock(间隙锁)来实现，可以避免幻读。

对于当前读，读到的往往是最新的行数据，但是对于事务1更新了一行（利用一个非唯一索引进行更新），同时事务2插入了一个新行，那么会利用gap锁去控制新行的插入来避免这个问题。

实现：（select ... lock in share mode，select ... for update，insert，update，delete）

## Sql语句加锁分析
写的非常经典，一看就会。
https://www.jianshu.com/p/13f5777966dd

## Mysql索引优化思路
1. 优先使用自增key作为主键
2. 最左前缀匹配
3. 索引列不能参与计算
4. 能扩展就不要新建索引（如已有索引a，想建立索引a_b，则尽量修改索引a为索引a_b）
5. 不需要建立前缀有包含关系的索引（如已有索引a_b，则不需要再建立索引a）
6. 选择区分度高的列作为索引，在性别字段上加索引几乎无效。

## 索引分类

#### 逻辑角度
1. 主键索引：特殊的唯一索引，不允许为空
2. 唯一索引：索引值唯一，但允许为空
3. 普通索引：普通索引
4. 组合索引：一个表中的数据在查询时有多个字段总是同时出现，可建立组合索引

复合索引是在多个字段上创建的索引。复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。

索引基数是指索引中不重复的值的数量；索引列的基数越大，索引效果越好。创建复合索引，复合索引可以提高查询效率。因为复合索引的索引基数会更大。

#### 存储角度
1. 聚集索引（主键索引）：叶子节点存的数据是整行数据( 即具体数据 )
2. 非聚集索引（辅助索引）：叶子节点存的数据是整行数据的主键

当通过辅助索引来查询数据时，需要进过两步：首先InnoDB存储引擎会遍历辅助索引找到主键。然后再通过主键在聚集索引中找到完整的行记录数据。

#### 数据结构角度
1. B+树索引：多叉树，深度小
2. hash索引：基于hash表实现，优点是查找快（不支持范围查询）