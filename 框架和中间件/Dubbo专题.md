# dubbo

## 说一下dubbo的工作流程

1. provider向注册中心去注册
2. consumer从注册中心订阅服务
3. 注册中心主动推送变更信息到consumer
4. consumer调用provider
5. 监控中心会统计服务调用次数和时间。

## 注册中心挂了还可以继续通信吗?

可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

## duboo支持哪些通信协议？支持哪些序列化协议？为什么Protocal Buffers性能高?

dubbo通信走dubbo协议，进行NIO异步通信，基于hessian作为序列化协议，与每个消费者维持一个长连接，可以支撑高并发请求。

长连接：建立连接过后可以持续发送请求，无须再建立连接。
短连接：每次发送请求之前，需要先重新建立一次连接。

序列化协议：
1. rmi协议，走java二进制序列化
2. hessian协议，走hessian序列化
3. http协议，走json序列化
4. webservice，走SOAP文本序列化

Protocol Buffer是Google提供的一种数据序列化协议，Protocol Buffers是一种轻便高效的结构化数据存储格式，性能很高。

## dubbo负载均衡策略和集群容错策略是啥？

默认使用随机调用负载策略，可以对provider不同实例设置不同的权重，会按照权重来负载均衡。
默认使用失败自动切换，自动重试其他机器的集群容错策略。
默认使用javassist生成动态字节码，创建代理类。但是我们可以通过spi扩展机制配置自己的动态代理策略。

## dubbo的spi是啥？

spi是service provider interface，比如你有个接口，现在这个接口有3个实现类，那么在系统运行的时候对这个接口选择哪个实现类呢？这就需要spi了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。

spi机制一般用在哪儿呢？插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你得开源框架里面，从而扩展某个功能，这个时候spi思想就用上了。

## 关于dubbo
dubbo默认采用netty进行TCP通讯。TCP是传输层协议
连接方式：长连接；传输协议：TCP；传输方式：NIO异步传输；序列化：Hessian二进制序列化；适用范围：传入传出参数数据包较小；适用场景：常规远程服务方法调用