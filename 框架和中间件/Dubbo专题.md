# dubbo

## 说一下dubbo的工作流程
1. provider向注册中心去注册
2. consumer从注册中心订阅服务
3. 注册中心主动推送变更信息到consumer
4. consumer调用provider
5. 监控中心会统计服务调用次数和时间。

## 注册中心挂了还可以继续通信吗?
可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

## duboo支持哪些通信协议？
dubbo通信走dubbo协议，进行NIO异步通信，基于hessian作为序列化协议，与每个消费者维持一个长连接，可以支撑高并发请求。

- 长连接：建立连接过后可以持续发送请求，无须再建立连接。
- 短连接：每次发送请求之前，需要先重新建立一次连接。

## dubbo支持哪些序列化
1. rmi协议，走java二进制序列化
2. hessian协议，走hessian序列化
3. http协议，走json序列化
4. webservice，走SOAP文本序列化

## dubbo负载均衡策略
默认使用随机调用负载策略，可以对provider不同实例设置不同的权重，会按照权重来负载均衡。
### 随机策略
比较均匀，可以按照设置的权重随机访问

### 轮询策略
会存在执行比较慢的服务提供者堆积请求的情况

### 最小活跃调用数
每个服务提供者里面维护一个活跃数计数器，用来记录当前同时处理的请求个数，也就是并发处理任务的个数，优先请求活跃数小的。

### 一致性hash策略
相同参数的请求总是发到同一提供者

## dubbo集群容错策略
1. 失败启动切换，失败后重试其他服务器（默认）
2. 快速失败，只发起一次调用，失败立刻报错
3. 失败自动回复，后台记录失败请求，定时重发

## dubbo的spi是啥？
spi是service provider interface，比如你有个接口，现在这个接口有3个实现类，那么在系统运行的时候对这个接口选择哪个实现类呢？这就需要spi了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。

spi机制一般用在哪儿呢？插件扩展的场景，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你得开源框架里面，从而扩展某个功能，这个时候spi思想就用上了。

## JDK的spi是啥
当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要在代码里制定。jdk提供服务实现查找的一个工具类java.util.ServiceLoader

## dubbo的特性
- 默认采用netty进行TCP通信；
- 连接方式：长连接；
- 传输协议：TCP（TCP是传输层协议）；
- 传输方式：NIO异步传输；
- 序列化：Hessian二进制序列化；
- 适用范围：传入传出参数数据包较小；
- 适用场景：常规远程服务方法调用

## Dubbo是如何利用zookeeper实现注册发现?
重点：文件系统、通知机制
所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除。新机器加入也是类似，所有机器收到通知：新兄弟目录加入。