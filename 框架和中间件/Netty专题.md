## 一个故事讲清Netty线程模型
假设某银行只有10个职员。该银行的业务流程分为以下4个步骤：
1. 顾客填申请表（5分钟）；
2. 职员审核（1分钟）；
3. 职员叫保安去金库取钱（3分钟）；
4. 职员打印票据，并将钱和票据返回给顾客（1分钟）。

我们看看银行不同的工作方式对其工作效率到底有何影响。

### BIO方式
每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。

我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。

这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。

### NIO方式
思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。

具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。

我们计算下这种工作方式下银行一个小时到底能处理多少顾客？假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。可见工作方式的转变能带来效率的极大提升。

这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图
[NIO图](http://dl2.iteye.com/upload/attachment/0130/5437/c519d8fd-d14e-397c-8b20-044a40b21eca.png)

mainReactor线程负责监听serversocket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。

可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。


## 什么是TCP粘包和拆包？
要发送的数据大于TCP发送缓冲区剩余空间大小，TCP在传输前进行拆包。
要发送的数据小鱼TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次性发送出去，这称为粘包。


## TCP粘包和拆包有什么解决办法？
1. 客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果发送的数据长度不足1024，则通过补充空格的方式补齐

## select poll epoll区别
I/O 多路复用其实是单个线程通过记录跟踪每一个socket（I/O流）的状态来管理多个I/O流。
在一个连接上同时处理多个请求响应，这样可以大大的减少连接的数量，并提高了网络的处理能力。

select, poll, epoll 都是I/O多路复用的具体的实现。epoll性能比其他二者要好。

## epoll
epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。

假设你在大学读书，住的宿舍楼有很多间房间，你的朋友要来找你。 select版宿管大妈就会带着你的朋友挨个房间去找，直到找到你为止。而 epoll版宿管大妈会先记下每位同学的房间号，你的朋友来时，只需告诉你的朋友你住在哪个房间即可，不用亲自带着你的朋友满大楼找人。如果来了 10000个人，性能可想而知。