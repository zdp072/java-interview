## redis为单线程，为啥性能还那么高？
1. 纯内存操作
2. 核心基于非阻塞的IO多路复用机制同时监听多个socket
3. 单线程反而避免了多线程的频繁上下文切换问题

## redis有哪些数据类型？
redis相比其他的KV数据库，其一大特点就是支持丰富的数据类型。
1. String（字符串）
2. List（双向链表）
3. Hash（字典）
4. Set（集合）
5. Sorted Set（有序集合）

## redis的key的过期策略是什么？
定期删除+惰性删除

所谓的定期删除，指的是redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。定期删除可能会导致很多过期的key到了时间并没有被删除掉，所以需要惰性删除。

所谓的惰性删除就是你在获取某个key的时候，redis会先检查一下，这个key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除，不会被你返回任何东西。

上面两种手段结合起来，可以保证过期的key一定会被删除。

以上方案实际上还是有问题，如果定期删除漏掉了很多过期key，然后你也没及时去查，也没走惰性删除，此时大量过期的key堆积在内存中，导致redis内存快耗尽了，咋办？ 答: 走内存淘汰机制，使用LRU内存淘汰策略，当内存不足以写入新的数据时，移除最近最少使用的key。

## redis主从复制的核心原理
redis的主从架构，主负责写，并且将数据复制到其他的slave节点；从节点负责读，所有的读请求全部走从节点。这样可以轻松实现水平扩容，支持读高并发。

redis采用异步的方式复制数据到slave节点，一个master节点是可以配置多个slave节点的，slave节点可以连接其他的slave节点，slave节点做复制的时候，是不会阻塞master节点的正常工作的，也不会阻塞对自己的查询操作，它用旧的数据来提供服务。slave节点主要用来进行横向扩容，做读写分离，扩容slave节点可以提高读的吞吐量。

## redis的哨兵是咋回事，能保证数据不丢失吗？
redis的哨兵负责监控master和slave进程是否正常工作；如果master出现故障，将会自动转移到slave；从而实现redis集群的高可用。
哨兵+redis主从架构是不保证redis数据零丢失的，只能保证redis集群的高可用。主备切换的时候数据有可能会丢失。

### 异步复制导致的数据丢失
master复制数据到slave是异步的，所以有可能部分数据还没有复制到slave，master就宕机了，此时这部分数据就丢失了。

### 脑裂导致的数据丢失
脑裂是说某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 这个master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，这就是所谓的脑裂。

此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。当网络再次恢复的时候，旧 master 会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。

### 数据丢失的解决方案
设置两个配置项，表示要求至少有1个slave，数据复制和同步的延迟不能超过10秒。
min-slaves-to-write 1    
min-slaves-max-lag 10

## redis持久化有几种方式？不同的持久化有什么优缺点？
### 持久化有两种方式：
RDB：对redis中的数据执行周期性的持久化。（定时生成）
AOF：对每条写入命令作为日志写入一个日志文件中，在redis重启的时候回访AOF日志中的写入指令恢复数据。（类似数据库binlog）
如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。

### 优缺点
RDB适合做冷备，因为恢复速度更快。因为RDB文件是定时每隔一定时间生成，所以redis宕机的时候，将会丢失最近一段时间的数据。
AOF日志文件的命令通过可读的方式记录，这个特性非常适合做灾难性的误操作的紧急恢复。

我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

## 分布式寻址算法：
### hash
来了一个key，首先计算hash值，然后对节点数取模。然后打在不同的master节点上，一旦某个master节点宕机，所有请求过来，都会基于最新的剩余的master节点数取模，尝试去取数据。这回导致大部分的请求过来，全部无法拿到有效的缓存，大量的流量将涌入数据库。

### 一致性hash
将整个hash值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，然后将各个master节点按服务器ip进行hash，这样就可以确定每个节点在hash环上的位置。

来了一个key，首先计算hash值，并确定此数据在环上的位置，从此位置沿环顺时针行走，遇到的第一个master节点就是key所在的位置。如果一个节点挂了，收影响的数据仅仅是此节点到环空间前一个节点之间的数据，其他不受影响。增加一个节点也同理。

然而，一致性hash算法在节点数太少时，容易因为节点分布不均匀而造成缓存热点的问题，为了解决这个问题，一致性hash算法引入了虚拟节点机制，即对每一个节点计算多个hash（ip加多个编号做hash），每个计算结果位置都放置一个虚拟节点，这样就实现了数据的均匀分布。

## 什么是redis雪崩、穿透、击穿？
### redis雪崩：
缓存宕机，导致请求全部打在DB上，导致DB被流量打死。
解决办法：事前：redis高可用（主从+哨兵）避免全盘崩溃。事中：本地缓存+限流降级，避免DB被打死。事后：redis持久化，一旦重启，从磁盘加载数据，快速恢复缓存数据。

### redis穿透：
缓存查不到，DB也查不到，导致请求每次都打在DB上。
解决办法：数据库没查到就写个空值到缓存中，并设置一个过期时间。下次有相同的key来访问，在缓存失效之前，都可以直接从缓存中取数据。

### redis击穿：
某个key非常热点，访问非常频繁，当这个key失效时，大量的请求涌向数据库。
解决办法：将该key设置为永不过期，或者使用分布式锁，第一个请求构建完缓存之后才释放锁。

## 如何保证缓存和数据库双写一致性？
### 缓存和数据库读写模式：
读的时候先读缓存，缓存没有的话，就读数据库，然后取出数据放入缓存。
更新的时候，先更新数据库，然后再删除缓存。（懒加载，需要的时候再重新算）

### 最初级的缓存不一致问题及解决方案
先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现不一致了。
解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。

### 比较复杂的数据不一致问题分析
数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一致。 

## redis的并发竞争是什么？如何解决？
多为的并发竞争，是说多个客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据错乱。
可以使用分布式锁，确保统一时间，只能有一个实例在操作某个key，别人不允许读和写。
你要写入缓存的时候，都是从mysql中查出来，这些数据都有一个创建时间戳。每次写缓存之前，先判断一下当前这个value的时间戳是否比缓存里的value的时间戳更新，如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。