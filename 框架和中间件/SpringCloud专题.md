## 什么是springcloud
springcloud是一系列框架的集合，它利用springboot开发的便利性巧妙地简化分布式系统基础设施的开发，如服务注册发现、配置中心、消息总线、负载均衡、断路器、数据监控，使用springboot的开发风格做到一键启动和部署。

## springcloud核心组件有哪些
- Eureka：服务注册与发现
- Feign：基于动态代理机制，拼接请求url地址，发起请求
- Ribbon：实现客户端负载均衡，从一台服务的多台机器中选择一台
- Hystrix：提供线程池，不同的服务走不同的线程池，实现不同服务调用的隔离，避免了服务雪崩的问题
- Zuul：服务网关，由zuul网关转发请求给对应的服务

## Eureka的底层实现原理
服务启动后会向eureka注册，eureka server会将注册信息向其他eureka server进行同步，当服务订阅者要调用服务提供者，则向eureka server获取服务提供者地址，服务订阅者会将服务提供者地址缓存在本地，下次调用时，则直接从本地缓存中取，完成一次调用。

当服务注册中心eureka server检测到服务提供者宕机或网络原因不可用时，在服务注册中心将服务置为下线状态，并将信息通知给服务消费者，订阅此服务的服务订阅者会更新本地缓存。

服务提供者在启动后，默认30秒向eureka server发送心跳，以证明当前服务是可用状态。eureka server默认90秒未收到服务提供者心跳，则认为其宕机。

## 为什么使用Eureka而不是Zookeeper做服务注册发现？
#### Zookeeper保证CP
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接宕掉不可用。也就是说服务注册功能对可用性的要求高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障和其他节点失去联系时，剩余节点会重新进行leader选举。问题在于选举的leader时间太长，比如30-120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。这种网络问题是大概率会发生的事，虽然服务最终可以恢复，但漫长的选举时间导致的注册长期不可用是不能容忍的。

#### Eureka保证AP
eureka在设计的时候就优先保证可用性，eureka每个节点都是平等的，几个节点挂掉不会影响正常的节点的工作，剩余的节点依然可以提供注册和查询服务。而eureka的客户端在向某个eureka server注册时如果发现连接失败，则会自动切换至其他节点，只要还有一台eureka server在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证一致性），除此之外，eureka server还有一种自我保护机制，具体见下文。所以eureka可以很好的应对网络故障导致的部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。

## 什么是eureka的自我保护机制？
默认情况下，如果eureka server在一段时间内没有接受到某个微服务实例的心跳，便会注销该实例（默认为90秒）。

当eureka server节点在短时间内丢失了过多实例的连接（网络故障或频繁启停客户端），那么该节点将会进入自我保护模式，一旦进入了该模式，eureka server将不会删除服务注册表中的数据（即不会注销任何微服务）。当网络故障恢复后，该节点自动退出自我保护模式。

## zuul网关有哪些作用？
1. 请求转发
2. 灰度发布
3. 限流
4. 认证（jwt、oauth2）
5. 权限控制、ip白名单

## Zuul底层实现原理
zuul网关的核心是一系列的过滤器，这些过滤器可以对请求或者响应结果做一系列过滤，这里使用到了责任链设计模式，这些责任链不会直接进行通信，但可以通过责任链传递的RequestContext参数共享信息。

zuul接受到请求后，首先由前置过滤器进行处理，然后再由路由过滤器具体把请求转发到后端应用，然后再执行后置过滤器把执行结果写回给请求方，当上面任何一个类型过滤器执行出错时执行错误过滤器。

## Zuul有哪些过滤器
#### PRE Filters（前置过滤器）
请求转发到后端服务器前执行的过滤器，如：鉴权

#### ROUTING Filters（路由过滤器）
该过滤器的作用是把请求具体转发到后端服务器上

#### POST Filters（后置过滤器）
请求转发到后端服务器后执行的过滤器，如：收集请求耗时信息

#### ERROR Filters（错误过滤器）
当上面任何一个类型的过滤器执行出错时执行该过滤器

## Feign的实现原理是什么？
feign的关键机制就是使用了动态代理
1. 首先如果你对某个接口定义了@FeignClient注解，那么Feign就会针对这个接口创建一个动态代理。
2. 接着你要是调用这个接口，本质就是会调用Feign创建的动态代理。
3. Feign的动态代理会根据接口上的@RequestMapping等注解来动态构建你要请求的服务的地址。
4. 最后针对这个地址，发起请求、解析响应。


## Ribbon是怎样和eureka Feign结合的？
1. 首先ribbon从eureka中获取对应的服务注册表信息
2. 然后ribbon使用负载均衡算法选择一台机器
3. 最后Feign针对这台机器，构建并发起请求，调用这台机器

## 链路追踪的实现原理是什么？
1. 为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转时，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是Trace ID。

2. 为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也通过一个唯一标识来标记它的开始及结束，这个唯一标识就是Span ID。


## hystrix断路器机制是怎样的？
熔断器如同电力保险丝，它可以实现快速失败，如果后端服务不可用，断路器会直接切断请求链，避免发送大量无效的请求影响系统吞吐量，并且断路器有自我检测并恢复的能力。

当请求后端服务失败数量超过一定比例(默认50%)，断路器会切换到开路状态，这时所有请求会直接失败而不会发送到后端服务。断路器保持在开路状态一段时间后(默认5秒)，自动切换到半开路状态(HALF-OPEN)，这时会判断下一次请求的返回情况，如果请求成功，断路器切回闭路状态(CLOSED)，否则重新切换到开路状态(OPEN)。