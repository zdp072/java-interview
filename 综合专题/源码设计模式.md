# 源码中设计模式

# 结构型模式

## 适配器模式

#### 作用
常用于将一个新接口适配旧接口，使不兼容的接口兼容

#### 框架中应用
1. java.io.InputStreamReader(InputStream)
2. java.io.OutputStreamWriter(OutputStream)

---
## 桥接模式

#### 作用
将抽象和抽象的具体实现解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化
只要你在用面向接口编程，其实都是在用桥接模式。

#### 框架中应用
1. java.util.logging.Handler
2. java.util.logging.Formatter

---
## 组合模式

#### 作用
组合模式常用于递归操作的优化上，比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么这个设计模式你可以试试。总之，凡是有级联操作的，你都可以尝试这个设计模式。

#### 框架中应用
1. java.awt.Container # add(Component)

---

## 装饰者模式
#### 作用
给一个对象添加额外的功能；因此它也是子类化的一个替代方案。
可以为类添加新的功能；防止类继承带来的爆炸式增长

#### 框架中应用
1. java.io.BufferedInputStream(InputStream)

---
## 门面模式

#### 作用
为一组组件、接口、子系统提供简化版的接口
例如，我们向外提供的服务就尽量采用门面模式，然后这个服务再调用各种service做聚合。

#### 框架中应用


---
## 享元模式

#### 作用
共享对象，使用缓存减少对象访问时间。
只要是使用了缓存，基本都是在用享元模式。

#### 框架中应用
1. String常量池

---
## 代理模式

#### 作用
动态增加被代理类的功能
所有的开源框架都用到了动态代理技术

#### 框架中应用
1. JDK动态代理
2. RMI

---
# 创建型模式

## 抽象工厂模式

#### 作用
提供一个协议生成一系列的相关的对象
抽象工厂被称为工厂的工厂，用来创建多个类似的工厂
该模式和策略模式结合使用

#### 框架中应用
1. java.sql.Connection # createStatement()

---
## 构造者模式

#### 作用
通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。
将构造逻辑提到单独的类中，分离类的构造逻辑和表现

#### 框架中应用
1. java.lang.StringBuilder # append()
2. java.lang.StringBuffer # append()

---

## 工厂方法

#### 作用：
只是一个返回实际对象的方法

#### 框架中应用
1. java.lang.Proxy # newProxyInstance()
2. java.lang.Class # newInstance()

---
## 原型模式

#### 作用
复制对象（深拷贝、浅拷贝）
如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。

我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。

#### 框架中应用
1. java.lang.Object # clone()

---

## 单例模式

#### 作用
保证类中只有一个实例，提供一个全局的访问点。

#### 框架中应用
1. java.lang.Runtime # getRuntime()
2. Spring的bean默认就是单例

---

# 行为型模式

## 责任链模式

#### 作用
把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。

凡是带有Filter关键词的，基本都在用这个设计模式。在业务代码中用到拦截器的地方基本都在用这个设计模式。

#### 框架中应用
1. javax.servlet.Filter # doFilter()

---

## 命令模式

#### 作用
请求以命令的形式包裹在对象中，并传给调用对象

#### 框架中应用
1. java.util.concurrent.ThreadPoolExecutor # execute(Runnable command)

---

## 解释器模式

#### 作用
构建一个解释器，该解释器通过解释这些句子来解决该问题。
这种模式被用在SQL解析、符号处理引擎等。(用的不多)

#### 框架中应用
1. java.util.regex.Pattern

---

## 迭代器模式

#### 作用
用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

#### 框架中应用
1. java.util.Iterator

---

## 中介者模式

#### 作用
通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。
MQ其实就是中介者模式

#### 框架中应用
1. java.lang.reflect.Method # invoke()

---

## 备忘录模式

#### 作用
保持对象状态，需要时可恢复
例如你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ。

#### 框架中应用
1. java.io.Serializable

---

##  观察者模式

#### 作用
当对象间存在一对多关系时，则使用观察者模式。比如，当一个对象被修改时，则需要自动通知它的依赖对象。
我们业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如服务注册发现等。

#### 框架中应用
1. java.util.Observer
2. Spring ApplicationListener（定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都得到通知并被自动更新）

---

## 状态模式
运行时需要根据状态更改对象的行为
比如我们常见的订单状态或者XX状态，都能用上。

#### 作用

#### 框架中应用
1. javax.faces.lifecycle.LifeCycle # execute()

---

## 策略模式

#### 作用
定义一系列的算法,把每一个算法封装起来,并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化
常用来优化if/else

#### JDK中体现

1. 比较器Comparator
- 在Java的集合框架中，经常需要通过构造方法传入一个比较器Comparator，进行比较排序，使用的就是策略模式。

2. ThreadPoolExecutor中的拒绝策略
- 在创建线程池时，需要传入拒绝策略，如果当前运行的线程数超过maximumPoolSize时，将会使用传入的拒绝策略进行处理。
- AbortPolicy: 直接抛出异常
- CallerRunsPolicy: 只用调用者所在线程来运行任务
- DiscardOldestPolicy: 丢弃队列里最近一个任务来执行当前任务
- DiscardPolicy: 不处理，丢弃掉

3. Spring SimpleInstantiationStrategy（定义一系列算法，把它们一个个封装起来，并且可以相互替换）


## 模板方法模式

#### 作用
抽象类公开定义一个执行方法的模板，它的子类按需重写方法实现。
行为由父类控制，子类实现。

#### 框架中应用
1. java.util.concurrent.ThreadPoolExecuter # beforeExecute
2. java.util.concurrent.ThreadPoolExecuter # afterExecute
3. Spring JdbcTemplate（定义一个操作中算法的骨架，将一些实现步骤延迟到子类中）
---

## 访问者模式

#### 作用
将稳定的数据结构和易变的数据操作分离
在数据基础类里面有一个方法操作数据，访问者持有基础类引用

#### 框架中应用
1. 暂无
