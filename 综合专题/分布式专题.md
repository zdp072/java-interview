## 分布式系统中的Raft共识算法
### 算法原理
raft集群中每个节点都可以根据集群运行的情况在三种状态间切换：follower、candidate、leader。
leader向follower同步日志（业务数据），follower只从leader处获取日志。在节点初始启动时，节点的raft状态机将处于follower状态并被设定一个election timeout。
如果在这一时间周期内没有收到来自leader的heartbeat，节点将发起选举：节点在将自己的状态切换为candidate之后，向集群中其他follower节点发送请求，询问其是否选举自己成为leader。当收到来自集群中过半数节点的接受投票后，节点即成为leader，开始接受保存client的数据并向其他follower节点同步日志。leader节点依靠定时向follower发送heartbeat来保持其地位。任何时候如果其他的follower在election timeout期间都没有收到来自leader的heartbeat，同样会将自己的状态切换为candidate并发起选举。每成功选举一次，新leader的步进数都会比之前leader的步进数大1。

### 算法作用
raft共识算法的优点在于能高效的解决分布式系统中各个节点日志内容不一致问题，使集群具备一定的容错能力。即使集群出现部分节点故障、网络故障等问题，仍可以保证其他大多数节点正确的步进。即使集群中超过半数的节点出现故障，也能保证节点中的数据不会出现错误的结果。

[文章来源：https://www.infoq.cn/article/coreos-analyse-etcd](https://www.infoq.cn/article/coreos-analyse-etcd)

---

## 如何实现分布式session
### Session复制
在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。

优点：代码上不需要做支持和修改。
缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。
适用场景：只适用于Web服务器比较少且Session数据量少的情况。
可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。

### Session粘滞
将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。（ip hash）

优点：使用简单，没有额外开销。
缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。
适用场景：对稳定性要求不是很高的业务情景。

### Session集中管理
在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。

优点：可靠性高，减少Web服务器的资源开销。
缺点：实现上有些复杂，配置较多。
适用场景：Web服务器较多、要求高可用性的情况。
可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。


---


### 幂等问题解决思路
#### 查询操作
查询操作天然幂等

#### 删除操作
删除操作也是幂等的(删除的数据存在和不存在返回的结果不一样)

#### 唯一索引
数据库添加唯一索引，防止新增脏数据

#### token机制
token机制，防止表单重复提交

#### 悲观锁
获取数据的时候加锁
```
select * from table where id = xxx for update；
```

#### 乐观锁
通过版本号来控制

#### 分布式锁
通过分布式锁，保证insert或update是串行操作

#### select + insert
并发不高的后台系统，先查询下关键数据，判断是否已经执行过，再进行业务处理
注意：高并发系统不要用这种方法。

#### 状态机
如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的


---

## 分布式ID

### 特点
1. 全局唯一
2. 趋势递增

### 实现方案
#### UUID
##### 优点
本地生成，性能高；

##### 缺点
太长不方便存储，不适合做主键；

#### 雪花算法
##### 优点
生成速度快

##### 缺点
依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成
每台机器的时钟不可能完全同步，有可能出现不是全局递增

#### 数据库自增
##### 优点
1. 简单，数据库自带功能
2. 能够保证唯一
3. 能够保证递增性
4. 步长固定

##### 缺点
1. 可用性难以保证；数据库常见架构是一主多从+读写分离，生成自增id是写请求，主库挂了就废了。
2. 性能有上限；因为写入是单点，数据库主库的写性能决定id的生成性能上限。

#### Redis实现
使用redis的incrby实现递增，假设redis集群为5。可以初始化每台redis的初始值为1，2，3，4，5，然后步长为5

#### 服务化

数据库自增生成分布式ID有个缺点就是每次生成ID都要访问数据库，导致数据库写压力很大。那么我们可以通过批量的方式降低数据库写压力。

##### 实现方案
1. 增加一组服务Id-Service，DB中有一张表保存表名和当前ID的最大值
2. 服务启动初始化过程中，首先拉取当前的maxId，然后批量生成一批ID，放到Id-Service内存
3. 将最新的maxId写回数据库（这个地方要使用CAS乐观锁）

##### 优点
能够通过水平扩展的方式，达到分布式ID生成服务的无限性能
使用CAS保证不会生成重复的ID

##### 缺点
由于有多个service，生成的ID不是绝对递增的，而是趋势递增的
如果Id-Service重启，内存中可能会有一段已经申请的ID没有分配出去，导致ID空洞

## 限流的基本原理，漏桶和令牌桶限流的对比和差异性。
漏桶： 漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。

令牌桶：生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。