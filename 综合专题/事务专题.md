# 分布式事务

## 分布式事务了解吗? 你们是如何解决分布式事务的?

#### XA方案 (两阶段提交)

所谓的XA方案，即两阶段提交，这里有一个事务管理器的概念，它负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库，你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行commit操作；如果任何其中一个数据库回答不ok，那么就rollback。

这种分布式事务方案，对业务无侵入，适合在单块应用里，跨多个库的分布式事务，这个方案需要数据库支持XA协议，资源锁定时间太久，性能差。

#### TCC方案

TCC的全称为：Try、Confirm、Cancel
Try阶段：对各个服务的资源做检测以及对资源进行锁定或预留。
Confirm阶段：在各个服务中执行实际的操作。
Cancel阶段：如果任何一个服务的业务方法执行出错，那么这里就需要把执行成功的回滚。

这个方案用的较少，因为这个事务回滚严重依赖你自己写代码来回滚，会造成回滚代码量巨大。

#### 本地消息表

A系统在自己本地事务里操作的同时，插入一条消息到消息表；接着A系统把这个消息发送到MQ中去；B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么这个事务会被回滚，这样保证不会重复处理消息。B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；如果B系统处理失败了，那么就不会更新消息表状态，此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中，让B再次处理；这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B成功为止。

这个方案最大的问题在于严重依赖于数据库的消息表来管理事务，高并发场景不太适合。

#### 基于MQ消息事务

A系统先发送一个prepared消息到MQ，如果这个prepared消息发送失败就直接取消操作别执行了；如果这个消息发送成功，那么接着执行本地事务，如果成功就告诉MQ发送确认消息，如果失败就告诉MQ回滚消息；如果发送了确认消息，那么B系统就会接受到确认消息，然后执行本地事务；MQ会自动定时轮询所有prepared消息，回调A系统的一个接口询问，这个消息是回滚还是重新发送一次确认消息，一般来说这里我们可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这里可以避免本地事务执行成功，而确认消息却发送失败了。

这个方案里，如果系统B的事务失败了咋办？需要自动不断重试直到成功，重试超过一定次数，可以想办法通知A也回滚，或发送警报由人工来手工回滚。


#### fescar方案

fescar是在XA的基础上做了改进，XA的两阶段提交，第一阶段是prepare，第二阶段是commit或rollback，两个阶段资源都是锁定的。

fescar第一阶段将业务数据的更新和回滚日志写入到一个本地事务中提交，确保提交的业务数据的更新一定有相应回滚日志存在。同时可以马上释放本地事务锁定的资源。

fescar第二阶段如果决议是全局提交，因为第一阶段已经提交了，此时只需要异步清理回滚日志。如果决议是全局回滚，那么可以通过回滚日志生成SQL执行回滚操作。



---
# 数据库事务

## 事务隔离级别
#### 未提交读(Read Uncommitted)
一个事务可以读取到另一个事务未提交的数据，会导致脏读。如果B事务回滚了，就会造成数据的不一致。
Read Uncommitted是事务最低的隔离级别。

#### 提交读(Read Committed)
只能读取到已经提交的数据。可以避免脏读，但在同一个事务中，由于其他事务的影响，两次select的数据有可能不一样，这就存在不可重复读的问题。

Oracle等多数数据库默认都是该级别 (RC)

#### 可重复读(Repeated Read)
InnoDB RR级别可以解决不可重复读的问题，即在这种隔离级别下，在一个事务中我们能够保证能够获取到一样的数据（即使已经有其他事务修改了我们的数据）。但是无法避免幻读，幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致，但是不同数据库对不同的RR级别有不同的实现，有时候或加上间隙锁来避免幻读。

注：不可重复读针对update / 幻读针对的是insert

RR级别是可能产生幻读，这是在传统的RR级别定义中会出现的。但是在innoDB引擎中利用MVCC多版本并发控制解决了这个问题
MVCC就是用同一份数据临时保留多版本的方式的方式，实现并发控制。写操作会创建一个新版本，并发的读则依旧访问旧版本的数据。

#### 串行读(Serializable)
最高隔离级别，所有事务串行，性能最差，每次读都需要获得表级共享锁，读写相互都会阻塞


## 隔离级别延伸
在InnoDB RR模型中,我们虽然避免了幻读，但是存在一个问题，我们得到的数据不是数据中实时的数据，如果是对实时数据比较敏感的业务，这是不现实的。对于这种读取历史数据的方式，我们叫它快照读 (snapshotread)，而读取数据库当前版本数据的方式，叫当前读 (current read)。

很显然，在MVCC中：快照读：就是select，select * from table ….;

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
1. select * from table where ? lock in share mode;
2. select * from table where ? for update;
3. insert;
4. update;
5. delete;

事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert、delete这些“当前读”，就需要另外的模块来解决了。

参考文章：https://blog.csdn.net/hellozhxy/article/details/81081187

---
# Spring事务

## Spring管理事务方式
#### 编程式事务
利用手动代码编写事务相关的业务逻辑

#### 声明式事务
为了避免我们每次都手动写代码，利用Spring AOP的方式对每个方法代理环绕，利用xml配置或注解避免了写代码。

## Spring事务传播

#### Required
如果当前存在一个事务，则加入该事务，否则将新建一个逻辑事务

#### RequiresNew
每次都创建新的事务

#### Supports
如果当前存在事务，就加入到该事务，如果当前没有事务，就以非事务方式执行

#### NotSupported
不支持事务，以非事务方式执行，如果当前存在事务，就把当前事务暂停，以非事务方式执行。

#### Mandatory
必须有事务，当运行在事务中则以当前事务运行，如果没有运行在事务中，则抛出异常

#### Never
不支持事务，以非事务方式执行，如果当前存在事务，则抛出异常

#### Nested
嵌套事务支持，如果当前存在事务，则在嵌套事务内执行，如果当前不存在事务，则创建一个新的事务，嵌套事务使用数据库中的保存点来实现，即嵌套事务回滚不影响外部事务，但外部事务回滚将导致嵌套事务回滚。

#### Nested和RequiresNew的区别
1. RequiresNew每次都创建新的独立的事务，而Nested只有一个事务；

2. Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而RequiresNew由于都是全新的事务，所以之间是无关联的；

3. Nested使用JDBC的保存点(save point)实现，即如果使用低版本驱动将导致不支持嵌套事务。